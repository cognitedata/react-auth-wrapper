# My Experience Creating MSAL React Native Proof of Concept
I've been working at Microsoft this summer as a Software Engineer Intern, an experience which so far has been insightful and really fun. From what I had read and heard from friends, Microsoft has one of the best tech (and maybe best overall) college internship programs, with an emphasis on work/life balance, signature events with puzzles or a guest performer, lots of swag, and a great returning offer rate at the end. When COVID-19 struck, I couldn't help but wonder if I was still going to have an internship this summer. Fortunately, Microsoft kept nearly all interns aboard, and they decided to switch their usually in-person program to be virtual. Although I was really looking forward to working in Redmond and exploring the Seattle area with my friends, I was also incredibly thankful to have this opportunity to work for Microsoft, even if that meant I had to stay at home.

## My Project
I work within Azure Identity on the DevEx JavaScript (JS) SDK team. My team builds and maintains the [Microsoft Authentication Library (MSAL)](https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-overview) as well as the Active Directory Authentication Library (ADAL) for JS, although more development is focused on MSAL, the newer of the two libraries. [MSAL JS](https://github.com/AzureAD/microsoft-authentication-library-for-js) allows client-side JS web applications to authenticate users using Azure Active Directory for work and school accounts (AAD), Microsoft personal accounts (MSA), and social identity providers through Azure AD B2C service. On the authorization side, MSAL can retrieve access tokens to call secure web APIs.

My team mentioned multiple times that there is a learning curve to what the authentication client teams do (and maybe even what Identity does, in general). I spent much of the first week reading Microsoft documentation and familiarizing myself with the GitHub libraries on MSAL. 

### Choosing My Project

In my first meeting with my manager, he asked what I wanted to do for my project. I had no idea where to even start! I felt that I still didn't have a great grasp of my team's code, much less how I could contribute. However, my manager also mentioned that my project should be "orthogonal" to the team. This means it would be a feature not in the team's current workload, but a plus to have (and could be implemented in the future!). With this in mind, I started to ask my teammates about features they would like to see added to the library that could reasonably be the focus of my project. Most of them directed me to an engineer on our team who had two great ideas for me.

The first was a website for the MSAL library, scoped to JavaScript at first. Because much information regarding MSAL exists in multiple places online through Microsoft docs, GitHub, and probably more, a well-organized website combining all this information could be beneficial to the MSAL teams. I took a web development course a year ago where I learned how to create basic websites. I knew this would be a project that I could reasonably get done early and then spend extra time with the UI to make it unique. However, the MSAL JS team doesn't specialize in making websites. They add to and maintain a library that web developers use, and I wanted to learn more about what actually happens under the hood and make proper use of their expertise.

The second idea was a proof of concept MSAL for React Native. [React Native](https://reactnative.dev/) is a framework that allows JS developers to create truly native mobile applications. Before this meeting, I had never heard of React Native, and it blew my mind that cross mobile platform frameworks like it existed. When I mentioned I had some Android experience, the engineer suggested that I create a proof of concept focusing on the Android side. I got pretty excited about this project for many reasons. One was that I knew I was going to learn a ton, from React Native to MSAL (and just getting more comfortable with JS in general). I also had a decent starting point with my knowledge of Android, so I would start the project with some prior knowledge. Additionally, I would get to create a libraryâ€¦ which is pretty awesome. 

Before I spoke with my manager again, I wrote up some pros and cons for each project and made loose plans as to how I would implement them. When the time came to decide, I realized that I was way more excited about MSAL for React Native, and I knew it would provide a great challenge for me to tackle during the summer. My manager asked me to write a requirements doc for my project:

**Ultimate Goal of the Project: Create a proof of concept MSAL for React Native that implements the Authorization Code Flow with PKCE (Proof Key Code Exchange).**

**Functional Requirements (and scoping):**
* The project will provide methods for mobile apps created with React Native to acquire OAuth2.0 access tokens by implementing the Authorization Code Flow with PKCE (mobile app that calls a web API on behalf of an interactive user).
    * The user will be authenticated with a broker (such as Authenticator), using either a redirect or pop-up flow, to get consent and allow SSO.
* Implementation will be focused on creating a library for Android; with my experience with creating Android apps (and lack of experience with iOS), I can put more time into the quality of the proof of concept and less time learning the nuances of iOS.
*	The project will be a wrapper of MSAL for Android but will stylistically be derived and will take inspiration from the MSAL JS libraries.
    *	The "MSAL React Native wrapper for iOS and Android" library by Stash Energy will also be referenced when designing and implementing the proof of concept.
*	The proof of concept will allow single-account mode only.
*	The project will center on AAD and not B2C nor ADFS.
*	A sample Android app will be created to demo the library.
*	Error handling will not be emphasized (unless I have extra time!).

**Non-Functional Requirements:**
*	The resulting library will stylistically match that of the existing MSAL JS libraries.
*	The project will follow good coding practices (being aware of third-party coding practices, and asking for advice when necessary).
*	The amount of code to be implemented on the user's end will be minimized.
    * Users should be able to add their client IDs, Tenant IDs, etc. and then use the libraries without much other configuration.
*	There will be proper usage documentation for the library as well as the sample app.
*	Code reviews will be done with team, Android point-of-contacts, and React Native engineers when necessary.

**Extra Add-Ons If Time:**
*	The sample Android app UI will be improved to match Microsoft's style.
*	Multiple-Accounts mode can be looked into.

We planned this to be a 10 week project, with a timeline as follows:

**Milestones (Broad):** Ten Week Project (5/24-7/31)
*	Week 1 (5/24-5/29): Write up requirements, scoping, and other planning; spend hackathon time diving into React Native.
*	Week 2 (6/1-6/5): Plan out functional requirements in detail (as well as the milestones for weeks 3 - 9).
*	Week 3 (6/8 - 6/12): Create demo app framework using React Native; start creating PPT for React Native Brownbag.
*	Week 4 (6/15 - 6/19): Finalize React Native PPT and present! Start implementing MSAL for React Native Library if haven't done so yet.
*	Week 5 - 9 (6/22 - 7/24): Code MSAL for React Native! (This will be better planned out in week 3).
*	Week 10 (7/27 - 7/31): Refine code (linting?) and usage documentation; start finishing blog post detailing my project's functionality and my experience building it; if demos are this week, demo; otherwise, practice demoing.

### Learning More About React Native and MSAL
As Week 1 of the plan states, there was a hackathon among the auth client teams on Thursday and Friday. I decided to spend that time to learn the basics of React Native and potentially create a demo app for testing my future library. I watched some LinkedIn Learning videos and spent a ton of time on React Native's and React's official website, since I also needed a refresher of React's basics. I followed tutorials using [Expo CLI](https://docs.expo.io/workflow/expo-cli/), which is great for beginners. After I felt more comfortable, I transitioned to using [React Native CLI](https://reactnative.dev/docs/0.61/getting-started), which was more bare-boned but necessary to use in order to incorporate native modules (more on this to follow). 
I aimed to create an app with a UI similar to that of [MSAL Android's sample app](https://github.com/Azure-Samples/ms-identity-android-java), and this was the result:

<img width="512" alt="MSALAndroidReactNative" src="https://user-images.githubusercontent.com/35305982/87815259-25f8f900-c81a-11ea-8029-48085eec4c5e.png">

The picture on the left is MSAL Android's sample app, and the picture on the right is my React Native sample app written entirely in React Native JS. I thought it was pretty successful! Of course, the app had no functionality, but it was a great base for what was still to come. 

The next week, I took a deeper look into how I would implement my library using a [Native Module](https://reactnative.dev/docs/0.18/native-modules-android). Native Modules allow developers to utilize code written in a native language (in my case, Java) within their React Native apps. For example, [SharedPreferences](https://developer.android.com/reference/android/content/SharedPreferences) is a functionality available through native Android that has not officially been implemented for React Native.  A developer could wrap the SharedPreferences methods as bridge methods (annotated with @ReactMethod) in a native module, which are then bridged over to the React Native side, [like so](https://medium.com/mindorks/how-to-use-native-modules-in-react-native-android-hybrid-apps-62b67a2cc7ca).  Developers can also publish their Native Modules on npm so that other people can use their features without having to implement the same Native Module. It seemed to me that the best way to create MSAL for React Native would be to create a Native Module with methods wrapping MSAL for Android and then publishing it as an npm package. The [third-party MSAL React Native library](https://github.com/stashenergy/react-native-msal) I had been reading seemed to use this technique, but I would be using Java instead of Kotlin.

While researching, I also put together an informational presentation (a "BrownBag") on React Native for my team that went over what React Native is, the pros and cons of using it, and how people could get started on their own project. I wasn't (and still am not) an expert on React Native, but preparing for the presentation helped solidify what I had been learning. By the time I presented, I was super enthusiastic to share my findings, which I think helped me get even more excited about my project as well.

Throughout my internship, my mentor served as my go-to person regarding questions about MSAL, and we spent a good amount of time discussing how the [authorization code flow](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow) works. I think the following diagram does a great job explaining this:

![image](https://user-images.githubusercontent.com/35305982/87816010-715fd700-c81b-11ea-907e-f84938053603.png)

In this particular flow, a user signs in, and upon success, the authorization server (AAD) will return an authorization code. This authorization code can then be used to request an access and refresh token. The access token can be used to call a secured web API, and after a while, when the access token expires, the refresh token can be used to request a new access token. Since MSAL Android really focuses on the authorization code flow, this was fortunately the only flow that I needed to consider for my project. 
 
### Starting the Project
At some point, I had read lots of documentation and traced many examples regarding MSAL and Native Modules, but still felt that I wasn't one-hundred-percent understanding everything. I was itching to dive in and create something without a solid plan. Of course, I knew that this could possibly result in my messing up and wasting time. But I also remembered how in college, I had an easier time learning in classes that had more labs rather than lots of readings. I learn well by doingâ€¦ so I was willing to take that risk and make up for the lost time by working extra, if needed. 

Because my project was scoped to single account mode, I had to focus on the methods of [SingleAccountPublicClientApplication](https://docs.microsoft.com/en-us/java/api/com.microsoft.identity.client.singleaccountpublicclientapplication?view=azure-java-stable). With the advice of my mentor, I decided to start with wrapping the [signIn](https://docs.microsoft.com/en-us/java/api/com.microsoft.identity.client.singleaccountpublicclientapplication.signin?view=azure-java-stable#com_microsoft_identity_client_SingleAccountPublicClientApplication_signIn__NonNull_final_Activity__NonNull_final_String__NonNull_final_String_____NonNull_final_AuthenticationCallback_) method, since a user needs to be signed in when they try to acquire tokens. I followed a simple tutorial from [Medium](https://medium.com/mindorks/how-to-use-native-modules-in-react-native-android-hybrid-apps-62b67a2cc7ca), which showed me the syntax in the Native Module file and the other configurations (packager file, adding to reactInstanceManager, etc) that I needed to do. Somewhere along the way, I read that there was a npm library generator available that could do most of this work for me: [react-native-create-library](https://www.npmjs.com/package/react-native-create-library) (but if you're thinking about using this, scroll down further to read about a better package I found later in my internship). I backtracked and created a new project with this command. With guidance from MSAL Android's sample app, I typed out a tentative method for signIn that would return a Promise with the account information upon completion.

I wanted to test my method, but I first needed to register my app in the Azure portal. This proved to be more difficult than expected, but my Android point of contact and another engineer within the MSAL Android team were very helpful in getting this all set up. I also worked with an engineer on my team to get my library published as an npm package and added to my sample. Finally, I ran my app on my emulator and clicked the "SIGN IN" button. It was exciting to see the Microsoft sign in page load!

### Debugging and Pull Requests
Unfortunately, the good feelings didn't last too long, as I ran into a bug shortly after entering my username and password. The React Native console wasn't telling me too much, but my emulator's console directed me to a React Native bridge file that threw the error. This is when I learned that, as of when this post was written, bridge methods can only [bridge over standard data types](https://medium.com/shoutem/ways-to-pass-objects-between-native-and-javascript-in-react-native-c3dcae7bf4f5) such as integers, strings, booleans, arrays, and maps. In my case, I was returning a Promise that resolved with an [IAccount](https://docs.microsoft.com/en-us/java/api/com.microsoft.identity.client.iaccount?view=azure-java-stable) object, which was not supported. The quick solution was to create a helper function that converted an IAccount object into a [WritableMap](https://github.com/facebook/react-native/blob/master/ReactAndroid/src/main/java/com/facebook/react/bridge/WritableMap.java). With this fix, my app no longer crashed. While I think this was the best workaround for passing IAccount's information, I felt weird converting a well-formed object into a map, almost as if I were downgrading the object. I do think that when React Native starts to allow any type of object to be bridged over (which I imagine is more complex than it seems), my proof of concept should be modified to return these objects, keeping consistent with MSAL Android.

Now that at least one method of my library was working, it was time for my first pull request (PR)! Having engineers review my code was a pretty cool experience. Coming from a school background, where graders mostly look for functionality, I noticed that my reviews focused more on style. Other than the fact that clean code is expected at a major tech company, my team's code is open sourced, so it makes sense that code should be top-notch before being released for general use. A few of the reviews I got had to do with the naming of my module and its location, since it was currently in a personal repository. I figured I would start a new library from scratch in the MSAL mono repo to avoid any unintended bugs while trying to rename the module, which is intertwined through many files. To recreate the library with a different name, I found another npm package called [create-react-native-module](https://www.npmjs.com/package/create-react-native-module) that was based on react-native-create-library but allowed more flexibility with naming. It took a few tries (I had to recreate the library and sample app three times in totalâ€¦ a side effect of me jumping into the project early, maybe) but finally, everything was in the right place.

At this point, I was about three weeks into my project; I had presented my BrownBag and started my project a week ahead of schedule. After I was able to implement the signIn method, the other methods, including signOut, getAccount, isSharedDevice, acquireTokenSilent, and acquireToken, were straightforward. I would implement a method, create a pull request, address reviews, merge, and repeat. My manager advised me to create multiple, short PRs instead of infrequent, larger PRs, which I felt sometimes slowed my progress down but also made it easier for my team to review. I noticed that in some of my PRs, my team would review some aspects that weren't caught in the previous PR, which supported my manager's thinking.

### Finishing Touches
I was about done with coding my project by the end of the fifth week, which was much earlier than expected. My six methods were working well, and my sample app was successfully showcasing them. My manager and I soon talked about what I wanted to do for the rest of my internship. I expressed that I was looking into adding functionality for multiple-account mode and was confident it could be finished in the remaining weeks. My manager said that I could definitely do that, but he also brought up another option. He said that wrapping up a project ends up taking longer than we usually think. While I have a completed project, it might be a good idea to spend a good amount of time polishing it so that it's ready for demos during the last week. After I finish that, he said I could potentially work on fixing a bug or adding a small feature to the actual MSAL JS library. As much as I was looking forward to adding another feature to my project, I couldn't pass up the opportunity to work with the team directly. And my project's main goal as a proof of concept was achieved, anyway: by creating a native module that bridges single-account mode methods, I proved that MSAL React Native is very much possible to implement.

It took me another three weeks to write the necessary documentation, add little improvements, get my last PR reviewed (and address those reviews), and write this blog post. Tying up loose ends did take longer than expected, but I'm glad that I had the extra time to make sure my project looked great. 
 
My completed proof of concept library allows React Native developers to utilize MSAL Android's single-account mode methods, scoped to AAD. The sample app demonstrates each of the six bridge methods in the library, using retrieved access tokens to make API calls to Microsoft Graph as an example. 

![image](https://user-images.githubusercontent.com/35305982/87816653-8ab55300-c81c-11ea-8301-7c2a5b945f78.png)

## Learning from Potential Mistakes
     
Near the beginning of the post, I mentioned that I started creating the library without a solid plan. While I had a starting point, a few sub goals, and a decent idea of what the finished state should look like, there were some configuration aspects of the project that I decided to figure out as I was working. For some parts, this worked out alright; fiddling around with app registrations in the Azure Portal was more helpful than reading a lot of documentation, for example. There were other parts that did set me back temporarily, such as not using npm packages dedicated to creating libraries (unsure how I missed react-native-create-library in my initial research) and not establishing the naming and location of my project earlier. While I did lose a relatively small amount of time to these issues, I do remember the frustration of creating new projects over and over until I got it right. I could argue that this was part of the learning process, but I also think they were essential parts of starting the project that could have created more problems in the long run. For future projects, Iâ€™ll make sure to focus on establishing a stable starting point so that I can put my focus on the actual meat of the project.

Another potential mistake that I learned from early on in my project is not creating enough PRs. As discussed before, my manager advised me to create multiple small PRs rather than infrequent, larger PRs. This is because larger PRs are more difficult for peers to review due to the amount of changes and files they must look at. PRs could be open for a super long time for this reason, which isnâ€™t great when other teammates could be waiting for these changes and releasing their own PRs at the same time. Looking back, I could have written my first PR when I first created my project, which would have decreased the number of files included in subsequent PRs. I bet that my first PR may have been a bit confusing for the team since there were tons of extraneous files among the few I needed them to review. The next PRs were shorter, and I soon fell into a better routine. Iâ€™m thankful that I learned this early on rather than later in my career.


## Some Final Thoughts About My Project

I had a great time developing MSAL React Native and learned so much in a relatively short amount of time. Even though my work on this project is ending for the summer, I have some final thoughts that I will share for developers that may want to build upon MSAL React Native in the future. 

### Next Features (in order of how I would complete them)

* Multiple-account mode: MSAL Android's [multiple-account mode methods](https://docs.microsoft.com/en-us/java/api/com.microsoft.identity.client.multipleaccountpublicclientapplication?view=azure-java-stable) are similar to those in single-account mode, so wrapping the functions should pretty much be the same. To differentiate between the modes, the names of the bridge methods should be changed (acquireTokenSingle vs. acquireTokenMultiple, for example) or perhaps another module can be added to the library so that multiple-account and single-account modes are separated.
* B2C: This will be similar to adding multiple-account mode, but the [B2C MSAL Android methods will be called differently](https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-android-b2c). I would recommend creating a new module to separate the B2C bridge methods.
* iOS: I think the iOS native modules should be started once the Android portion of MSAL React Native is completed. The way the methods are wrapped across both platforms must be similar, and the way the bridge methods are called within React Native should be identical. Since I don't have iOS programming experience, I can't give a very good analysis on how the iOS side would be implemented, but the [React Native website has a great tutorial on creating native modules for iOS](https://reactnative.dev/docs/native-modules-ios) and [Stash Energy's React Native MSAL](https://github.com/stashenergy/react-native-msal) could serve as a great example, too.

### Ownership of Project

One thing I wondered about throughout my project is how MSAL React Native's work would be divided if it were to become officially supported. Although React Native is geared towards JS developers, creating the native modules would require coding in Java/Kotlin/Swift/Objective-C, which may be outside the scope of my team. The best-case scenario would be if an engineer from each of the MSAL Android, iOS, and JS teams could work on the library together, which would be a pretty awesome crossover. However, I am confident that members of the JS team could pick up Java/Swift relatively quickly and create the modules if needed, reaching out to the other two teams for reviews. In any case, I'm certain that supporting MSAL React Native would require a collaboration among these three MSAL teams, something that will be really cool to see in the future. 

## What I Learned About Being A Software Engineer

Because I havenâ€™t had a lot of team project experience in school, it was cool to see how a software engineering team operates. I know that in many corporate settings, itâ€™s easy for work to be stagnant, which can slow down projects considerably. This wasnâ€™t the case for my team. We had daily standups where each individual member talked about what they worked on the day before and what they hoped to accomplish for the rest of the day. We also had weekly design and backlog meetings that discussed long term project goals. I believe that these meetings helped keep my team accountable for their work. It seemed to me that my teammates were rarely working on the same thing for a prolonged amount of time, since they would either finish the work quickly or take on another part of a project. 

This may seem a bit intimidating from the outside (it was for me!), but the engineers on my team would always encourage questions, whether they are about work or more general software engineering topics. The engineers would also work together more often than I would expect. Pair programming was common, and although teammates worked with some people more than others if they shared a project, we also had Tech-Debt days where engineers could work on topics with different people each week. 

As a new intern, I really appreciated this collaborative environment. I was surprised at how well people were able to code together, especially virtually. I can only imagine that this would be even more productive in person! I also noticed that people were pulling their own weight and didnâ€™t have to be told to do so. While I canâ€™t speak for other teams, I liked how this was expected of everyone in my team, and I feel that working in a similar environment would help me grow.

Additionally, I liked that there was a large emphasis on continuous learning.  In the beginning of my internship, there was a hackathon among the auth client teams where engineers could work with others outside their team to create and learn. My team also had Domain Days, which consisted of a team member becoming an expert on an auth client related topic each week and presenting their findings. In the entire Identity org, there was one day every month that was set aside for learning something new, technical or not. I think itâ€™s awesome that there were so many opportunities for engineers to learn outside their main work. 

From what Iâ€™ve observed, being a software engineer at Microsoft requires an amazing worth ethic, a willingness to work well with others, and a strong desire to continuously learn, among other things. One general piece of advice that I remember my manager telling me is that itâ€™s alright, and perhaps even good, to be uncomfortable, for that is how people truly grow. This may sound weird, but I believe that this internship has made me a comfortable amount of uncomfortable, from feeling like I donâ€™t understand my teamâ€™s work at all to gradually learning enough to always pique my curiosity. Through this experience, I have been empowered to achieve more. 

## Special Thanks toâ€¦ 

Daryl, my manager; Thomas, my mentor; Hector, Jo, Jason, Sameera, Prithvi, Santiago, Jake, and Haley, the awesome engineers/PM of the DevEx JS SDK team; and Shane, my MSAL Android point of contact. You all made my Microsoft experience extra amazing ðŸ˜Š

